#include <iostream>
#include <cstdlib>
#include <algorithm>
#include <climits>
#include <cstring>
#include <string>
#include <assert.h>

using namespace std;

struct TreeNode{
  TreeNode * left;
  TreeNode * right;
  int val;
  TreeNode(int v):val(v),left(NULL),right(NULL);
};


// my version of converting array to binary search tree:
class Solution{
public:
  // convert a sorted array to binary search tree:
  TreeNode * sortedArrToBST(int arr[], int start, int end){
    // do this to avoid overflow:
    int mid = start + (end-start)/2;
    TreeNode * node = TreeNode(mid);
    node->left = sortedArrToBST(start, mid -1);
    node->right = sortedArrToBST(mid+1, end);
  }
  
  // the function to be called to convert the sorted array to BST 
  TreeNode * sortedArrToBST(int arr[], int n){
    sortedArrToBST(arr, 0, n-1);
  }

  void inorderTraversal(TreeNode * node){
    if(!node)
      return;
    inorderTraversal(node->left);
    cout<<"\t"<<node->val;
    inorderTraversal(node->right);

  }
  
  // print the numbers in the BST in order:
  void print(TreeNode * root){
    inorderTraversal(root);
    cout<<endl;
  }
};

int main(int argc, char** argv){
  Solution S;
  
  int* arr = (int *)malloc(sizeof(int)* (argc -1));
  for(int i = 1; i < argc; i ++){
     arr[i-1] = atoi(argv[i]);
  }
  
  //int arr [] = { 12 ,123, 12312, 42112, 13421, 1234,312, 314};
  //int n = sizeof(arr)/sizeof(int);
 
  TreeNode * root = S.sortedArrToBST(arr, argc -1);
  S.print(root);

  free(arr);
  return 0;

}
